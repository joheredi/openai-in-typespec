// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.

export interface ChatCompletionRequestMessage {
  /** The role of the messages author. One of `system`, `user`, `assistant`, or `function`. */
  role: RoleType;
  /**
   * The contents of the message. `content` is required for all messages, and may be null for
   * assistant messages with function calls.
   */
  content: string | null;
  /**
   * The name of the author of this message. `name` is required if role is `function`, and it
   * should be the name of the function whose response is in the `content`. May contain a-z,
   * A-Z, 0-9, and underscores, with a maximum length of 64 characters.
   */
  name?: string;
  /** The name and arguments of a function that should be called, as generated by the model. */
  functionCall?: FNCall;
}

/** Type of RoleType */
/** */
export type RoleType = "system" | "user" | "assistant" | "function";

export interface FNCall {
  /** The name of the function to call. */
  name: string;
  /**
   * The arguments to call the function with, as generated by the model in JSON format. Note that
   * the model does not always generate valid JSON, and may hallucinate parameters not defined by
   * your function schema. Validate the arguments in your code before calling your function.
   */
  arguments: string;
}

export interface ChatCompletionFunctions {
  /**
   * The name of the function to be called. Must be a-z, A-Z, 0-9, or contain underscores and
   * dashes, with a maximum length of 64.
   */
  name: string;
  /**
   * A description of what the function does, used by the model to choose when and how to call the
   * function.
   */
  description?: string;
  /**
   * The parameters the functions accepts, described as a JSON Schema object. See the
   * [guide](/docs/guides/gpt/function-calling) for examples, and the
   * [JSON Schema reference](https://json-schema.org/understanding-json-schema/) for documentation
   * about the format.\n\nTo describe a function that accepts no parameters, provide the value
   * `{\"type\": \"object\", \"properties\": {}}`.
   */
  parameters: Record<string, any>;
}

/** Type of Function_callType */
/** */
export type Function_callType =
  | "none"
  | "auto"
  | "ChatCompletionFunctionCallOption";

/** Represents a chat completion response returned by model, based on the provided input. */
export interface CreateChatCompletionResponse {
  /** A unique identifier for the chat completion. */
  id: string;
  /** The object type, which is always `chat.completion`. */
  object: string;
  /** The Unix timestamp (in seconds) of when the chat completion was created. */
  created: Date;
  /** The model used for the chat completion. */
  model: string;
  /** A list of chat completion choices. Can be more than one if `n` is greater than 1. */
  choices: Choices1[];
  usage?: CompletionUsage;
}

export interface Choices1 {
  /** The index of the choice in the list of choices. */
  index: number;
  message: ChatCompletionResponseMessage;
  /**
   * The reason the model stopped generating tokens. This will be `stop` if the model hit a
   * natural stop point or a provided stop sequence, `length` if the maximum number of tokens
   * specified in the request was reached, or `function_call` if the model called a function.
   */
  finishReason: Finish_reasonType;
}

export interface ChatCompletionResponseMessage {
  /** The role of the author of this message. */
  role: RoleType;
  /** The contents of the message. */
  content: string | null;
  /** The name and arguments of a function that should be called, as generated by the model. */
  functionCall?: FNCall;
}

/** Type of Finish_reasonType */
/** */
export type Finish_reasonType = "stop" | "length" | "function_call";

/** Usage statistics for the completion request. */
export interface CompletionUsage {
  /** Number of tokens in the prompt. */
  promptTokens: number;
  /** Number of tokens in the generated completion */
  completionTokens: number;
  /** Total number of tokens used in the request (prompt + completion). */
  totalTokens: number;
}

export interface Error {
  type: string;
  message: string;
  param: string | null;
  code: string | null;
}

/** Type of Response_formatType */
/** */
export type Response_formatType =
  | "json"
  | "text"
  | "srt"
  | "verbose_json"
  | "vtt";

export interface CreateTranscriptionResponse {
  text: string;
}

export interface CreateTranslationResponse {
  text: string;
}

export interface HyperParams {
  /**
   * The number of epochs to train the model for. An epoch refers to one full cycle through the
   * training dataset.
   *
   * "Auto" decides the optimal number of epochs based on the size of the dataset. If setting the
   * number manually, we support any number between 1 and 50 epochs.
   */
  nEpochs?: "auto";
}

export interface FineTuningJob {
  /** The object identifier, which can be referenced in the API endpoints. */
  id: string;
  /** The object type, which is always "fine_tuning.job". */
  object: "fine_tuning.job";
  /** The Unix timestamp (in seconds) for when the fine-tuning job was created. */
  createdAt: Date;
  /** The Unix timestamp (in seconds) for when the fine-tuning job was finished. */
  finishedAt: Date;
  /** The base model that is being fine-tuned. */
  model: string;
  /** The name of the fine-tuned model that is being created. */
  fineTunedModel: string | null;
  /** The organization that owns the fine-tuning job. */
  organizationId: string;
  /**
   * The current status of the fine-tuning job, which can be either `created`, `pending`, `running`,
   * `succeeded`, `failed`, or `cancelled`.
   */
  status: StatusType;
  /**
   * The hyperparameters used for the fine-tuning job. See the
   * [fine-tuning guide](/docs/guides/fine-tuning) for more details.
   */
  hyperparameters: HyperParams;
  /** The file ID used for training. */
  trainingFile: string;
  /** The file ID used for validation. */
  validationFile: string | null;
  /** The compiled results files for the fine-tuning job. */
  resultFiles: OpenAIFile[];
  /** The total number of billable tokens processed by this fine tuning job. */
  trainedTokens: number;
}

/** Type of StatusType */
/** */
export type StatusType =
  | "created"
  | "pending"
  | "running"
  | "succeeded"
  | "failed"
  | "cancelled";

/** The `File` object represents a document that has been uploaded to OpenAI. */
export interface OpenAIFile {
  /** The file identifier, which can be referenced in the API endpoints. */
  id: string;
  /** The object type, which is always "file". */
  object: "file";
  /** The size of the file in bytes. */
  bytes: number;
  /** The Unix timestamp (in seconds) for when the file was created. */
  createdAt: Date;
  /** The name of the file. */
  filename: string;
  /** The intended purpose of the file. Currently, only "fine-tune" is supported. */
  purpose: string;
  /**
   * The current status of the file, which can be either `uploaded`, `processed`, `pending`,
   * `error`, `deleting` or `deleted`.
   */
  status: StatusType;
  /**
   * Additional details about the status of the file. If the file is in the `error` state, this will
   * include a message describing the error.
   */
  statusDetails?: string | null;
}

export interface ListPaginatedFineTuningJobsResponse {
  object: string;
  data: FineTuningJob[];
  hasMore: boolean;
}

export interface ListFineTuningJobEventsResponse {
  object: string;
  data: FineTuningJobEvent[];
}

export interface FineTuningJobEvent {
  object: string;
  createdAt: Date;
  level: LevelType;
  message: string;
}

/** Type of LevelType */
/** */
export type LevelType = "info" | "warn" | "error";

/**
 * Represents a completion response from the API. Note: both the streamed and non-streamed response
 * objects share the same shape (unlike the chat endpoint).
 */
export interface CreateCompletionResponse {
  /** A unique identifier for the completion. */
  id: string;
  /** The object type, which is always `text_completion`. */
  object: string;
  /** The Unix timestamp (in seconds) of when the completion was created. */
  created: Date;
  /** The model used for the completion. */
  model: string;
  /** The list of completion choices the model generated for the input. */
  choices: Choices2[];
  usage?: CompletionUsage;
}

export interface Choices2 {
  index: number;
  text: string;
  logprobs?: LogProbs2;
  /**
   * The reason the model stopped generating tokens. This will be `stop` if the model hit a
   * natural stop point or a provided stop sequence, or `length` if the maximum number of tokens
   * specified in the request was reached.
   */
  finishReason: Finish_reasonType;
}

export interface LogProbs2 {
  tokens: string[];
  tokenLogprobs: number[];
  topLogprobs: Record<string, number>[];
  textOffset: number[];
}

export interface CreateEditResponse {
  /** The object type, which is always `edit`. */
  object: "edit";
  /** The Unix timestamp (in seconds) of when the edit was created. */
  created: Date;
  /** description: A list of edit choices. Can be more than one if `n` is greater than 1. */
  choices: Choices2[];
  usage: CompletionUsage;
}

/** Type of SizeType */
/** */
export type SizeType = "256x256" | "512x512" | "1024x1024";

export interface ImagesResponse {
  created: Date;
  data: Image[];
}

/** Represents the url or the content of an image generated by the OpenAI API. */
export interface Image {
  /** The URL of the generated image, if `response_format` is `url` (default). */
  url?: string;
  /** The base64-encoded JSON of the generated image, if `response_format` is `b64_json`. */
  b64Json?: Uint8Array;
}

export interface CreateEmbeddingResponse {
  /** The object type, which is always "embedding". */
  object: "embedding";
  /** The name of the model used to generate the embedding. */
  model: string;
  /** The list of embeddings generated by the model. */
  data: Embedding[];
  /** The usage information for the request. */
  usage: Usage;
}

/** Represents an embedding vector returned by embedding endpoint. */
export interface Embedding {
  /** The index of the embedding in the list of embeddings. */
  index: number;
  /** The object type, which is always "embedding". */
  object: "embedding";
  /**
   * The embedding vector, which is a list of floats. The length of vector depends on the model as\
   * listed in the [embedding guide](/docs/guides/embeddings).
   */
  embedding: number[];
}

export interface Usage {
  /** The number of tokens used by the prompt. */
  promptTokens: number;
  /** The total number of tokens used by the request. */
  totalTokens: number;
}

export interface ListFilesResponse {
  object: string;
  data: OpenAIFile[];
}

export interface DeleteFileResponse {
  id: string;
  object: string;
  deleted: boolean;
}

/** The `FineTune` object represents a legacy fine-tune job that has been created through the API. */
export interface FineTune {
  /** The object identifier, which can be referenced in the API endpoints. */
  id: string;
  /** The object type, which is always "fine-tune". */
  object: "fine-tune";
  /** The Unix timestamp (in seconds) for when the fine-tuning job was created. */
  createdAt: Date;
  /** The Unix timestamp (in seconds) for when the fine-tuning job was last updated. */
  updatedAt: Date;
  /** The base model that is being fine-tuned. */
  model: string;
  /** The name of the fine-tuned model that is being created. */
  fineTunedModel: string | null;
  /** The organization that owns the fine-tuning job. */
  organizationId: string;
  /**
   * The current status of the fine-tuning job, which can be either `created`, `running`,
   * `succeeded`, `failed`, or `cancelled`.
   */
  status: StatusType;
  /**
   * The hyperparameters used for the fine-tuning job. See the
   * [fine-tuning guide](/docs/guides/legacy-fine-tuning/hyperparameters) for more details.
   */
  hyperparams: HyperParams2;
  /** The list of files used for training. */
  trainingFiles: OpenAIFile[];
  /** The list of files used for validation. */
  validationFiles: OpenAIFile[];
  /** The compiled results files for the fine-tuning job. */
  resultFiles: OpenAIFile[];
  /** The list of events that have been observed in the lifecycle of the FineTune job. */
  events?: FineTuneEvent[];
}

export interface HyperParams2 {
  /**
   * The number of epochs to train the model for. An epoch refers to one full cycle through the
   * training dataset.
   */
  nEpochs: number;
  /**
   * The batch size to use for training. The batch size is the number of training examples used to
   * train a single forward and backward pass.
   */
  batchSize: number;
  /** The weight to use for loss on the prompt tokens. */
  promptLossWeight: number;
  /** The learning rate multiplier to use for training. */
  learningRateMultiplier: number;
  /** The classification metrics to compute using the validation dataset at the end of every epoch. */
  computeClassificationMetrics?: boolean;
  /** The positive class to use for computing classification metrics. */
  classificationPositiveClass?: string;
  /** The number of classes to use for computing classification metrics. */
  classificationNClasses?: number;
}

export interface FineTuneEvent {
  object: string;
  createdAt: Date;
  level: string;
  message: string;
}

export interface ListFineTunesResponse {
  object: string;
  data: FineTune[];
}

export interface ListFineTuneEventsResponse {
  object: string;
  data: FineTuneEvent[];
}

export interface ListModelsResponse {
  object: string;
  data: Model[];
}

/** Describes an OpenAI model offering that can be used with the API. */
export interface Model {
  /** The model identifier, which can be referenced in the API endpoints. */
  id: string;
  /** The object type, which is always "model". */
  object: "model";
  /** The Unix timestamp (in seconds) when the model was created. */
  created: Date;
  /** The organization that owns the model. */
  ownedBy: string;
}

export interface DeleteModelResponse {
  id: string;
  object: string;
  deleted: boolean;
}

export interface CreateModerationResponse {
  /** The unique identifier for the moderation request. */
  id: string;
  /** The model used to generate the moderation results. */
  model: string;
  /** A list of moderation objects. */
  results: Results1[];
}

export interface Results1 {
  /** Whether the content violates [OpenAI's usage policies](/policies/usage-policies). */
  flagged: boolean;
  /** A list of the categories, and whether they are flagged or not. */
  categories: Categories1;
  /** A list of the categories along with their scores as predicted by model. */
  categoryScores: CategoryScores;
}

export interface Categories1 {
  /**
   * Content that expresses, incites, or promotes hate based on race, gender, ethnicity,
   * religion, nationality, sexual orientation, disability status, or caste. Hateful content
   * aimed at non-protected groups (e.g., chess players) is harrassment.
   */
  hate: boolean;
  /**
   * Hateful content that also includes violence or serious harm towards the targeted group
   * based on race, gender, ethnicity, religion, nationality, sexual orientation, disability
   * status, or caste.
   */
  "hate/threatening": boolean;
  /** Content that expresses, incites, or promotes harassing language towards any target. */
  harassment: boolean;
  /** Harassment content that also includes violence or serious harm towards any target. */
  "harassment/threatening": boolean;
  /**
   * Content that promotes, encourages, or depicts acts of self-harm, such as suicide, cutting,
   * and eating disorders.
   */
  selfHarm: boolean;
  /**
   * Content where the speaker expresses that they are engaging or intend to engage in acts of
   * self-harm, such as suicide, cutting, and eating disorders.
   */
  "selfHarm/intent": boolean;
  /**
   * Content that encourages performing acts of self-harm, such as suicide, cutting, and eating
   * disorders, or that gives instructions or advice on how to commit such acts.
   */
  "selfHarm/instructive": boolean;
  /**
   * Content meant to arouse sexual excitement, such as the description of sexual activity, or
   * that promotes sexual services (excluding sex education and wellness).
   */
  sexual: boolean;
  /** Sexual content that includes an individual who is under 18 years old. */
  "sexual/minors": boolean;
  /** Content that depicts death, violence, or physical injury. */
  violence: boolean;
  /** Content that depicts death, violence, or physical injury in graphic detail. */
  "violence/graphic": boolean;
}

export interface CategoryScores {
  /** The score for the category 'hate'. */
  hate: number;
  /** The score for the category 'hate/threatening'. */
  "hate/threatening": number;
  /** The score for the category 'harassment'. */
  harassment: number;
  /** The score for the category 'harassment/threatening'. */
  "harassment/threatening": number;
  /** The score for the category 'self-harm'. */
  selfHarm: number;
  /** The score for the category 'self-harm/intent'. */
  "selfHarm/intent": number;
  /** The score for the category 'self-harm/instructive'. */
  "selfHarm/instructive": number;
  /** The score for the category 'sexual'. */
  sexual: number;
  /** The score for the category 'sexual/minors'. */
  "sexual/minors": number;
  /** The score for the category 'violence'. */
  violence: number;
  /** The score for the category 'violence/graphic'. */
  "violence/graphic": number;
}
