// <auto-generated/>

#nullable disable

using System;
using System.ClientModel;
using System.ClientModel.Primitives;
using System.Threading.Tasks;
using OpenAI.Internal.Models;

namespace OpenAI.Internal
{
    // Data plane generated sub-client.
    /// <summary> The VectorStores sub-client. </summary>
    internal partial class VectorStores
    {
        private const string AuthorizationHeader = "Authorization";
        private readonly ApiKeyCredential _keyCredential;
        private const string AuthorizationApiKeyPrefix = "Bearer";
        private readonly ClientPipeline _pipeline;
        private readonly Uri _endpoint;

        /// <summary> The HTTP pipeline for sending and receiving REST requests and responses. </summary>
        public virtual ClientPipeline Pipeline => _pipeline;

        /// <summary> Initializes a new instance of VectorStores for mocking. </summary>
        protected VectorStores()
        {
        }

        /// <summary> Initializes a new instance of VectorStores. </summary>
        /// <param name="pipeline"> The HTTP pipeline for sending and receiving REST requests and responses. </param>
        /// <param name="keyCredential"> The key credential to copy. </param>
        /// <param name="endpoint"> OpenAI Endpoint. </param>
        internal VectorStores(ClientPipeline pipeline, ApiKeyCredential keyCredential, Uri endpoint)
        {
            _pipeline = pipeline;
            _keyCredential = keyCredential;
            _endpoint = endpoint;
        }

        /// <summary> Returns a list of vector-stores. </summary>
        /// <param name="limit">
        /// A limit on the number of objects to be returned. Limit can range between 1 and 100, and the
        /// default is 20.
        /// </param>
        /// <param name="order">
        /// Sort order by the `created_at` timestamp of the objects. `asc` for ascending order and`desc`
        /// for descending order.
        /// </param>
        /// <param name="after">
        /// A cursor for use in pagination. `after` is an object ID that defines your place in the list.
        /// For instance, if you make a list request and receive 100 objects, ending with obj_foo, your
        /// subsequent call can include after=obj_foo in order to fetch the next page of the list.
        /// </param>
        /// <param name="before">
        /// A cursor for use in pagination. `before` is an object ID that defines your place in the list.
        /// For instance, if you make a list request and receive 100 objects, ending with obj_foo, your
        /// subsequent call can include before=obj_foo in order to fetch the previous page of the list.
        /// </param>
        /// <remarks> List vector stores. </remarks>
        public virtual async Task<ClientResult<ListVectorStoresResponse>> GetVectorStoresAsync(int? limit = null, ListOrder? order = null, string after = null, string before = null)
        {
            ClientResult result = await GetVectorStoresAsync(limit, order?.ToString(), after, before, null).ConfigureAwait(false);
            return ClientResult.FromValue(ListVectorStoresResponse.FromResponse(result.GetRawResponse()), result.GetRawResponse());
        }

        /// <summary> Returns a list of vector-stores. </summary>
        /// <param name="limit">
        /// A limit on the number of objects to be returned. Limit can range between 1 and 100, and the
        /// default is 20.
        /// </param>
        /// <param name="order">
        /// Sort order by the `created_at` timestamp of the objects. `asc` for ascending order and`desc`
        /// for descending order.
        /// </param>
        /// <param name="after">
        /// A cursor for use in pagination. `after` is an object ID that defines your place in the list.
        /// For instance, if you make a list request and receive 100 objects, ending with obj_foo, your
        /// subsequent call can include after=obj_foo in order to fetch the next page of the list.
        /// </param>
        /// <param name="before">
        /// A cursor for use in pagination. `before` is an object ID that defines your place in the list.
        /// For instance, if you make a list request and receive 100 objects, ending with obj_foo, your
        /// subsequent call can include before=obj_foo in order to fetch the previous page of the list.
        /// </param>
        /// <remarks> List vector stores. </remarks>
        public virtual ClientResult<ListVectorStoresResponse> GetVectorStores(int? limit = null, ListOrder? order = null, string after = null, string before = null)
        {
            ClientResult result = GetVectorStores(limit, order?.ToString(), after, before, null);
            return ClientResult.FromValue(ListVectorStoresResponse.FromResponse(result.GetRawResponse()), result.GetRawResponse());
        }

        /// <summary>
        /// [Protocol Method] Returns a list of vector-stores.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://aka.ms/azsdk/net/protocol-methods">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetVectorStoresAsync(int?,global::OpenAI.Models.ListOrder?,string,string)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="limit">
        /// A limit on the number of objects to be returned. Limit can range between 1 and 100, and the
        /// default is 20.
        /// </param>
        /// <param name="order">
        /// Sort order by the `created_at` timestamp of the objects. `asc` for ascending order and`desc`
        /// for descending order. Allowed values: "asc" | "desc"
        /// </param>
        /// <param name="after">
        /// A cursor for use in pagination. `after` is an object ID that defines your place in the list.
        /// For instance, if you make a list request and receive 100 objects, ending with obj_foo, your
        /// subsequent call can include after=obj_foo in order to fetch the next page of the list.
        /// </param>
        /// <param name="before">
        /// A cursor for use in pagination. `before` is an object ID that defines your place in the list.
        /// For instance, if you make a list request and receive 100 objects, ending with obj_foo, your
        /// subsequent call can include before=obj_foo in order to fetch the previous page of the list.
        /// </param>
        /// <param name="options"> The request options, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ClientResultException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual async Task<ClientResult> GetVectorStoresAsync(int? limit, string order, string after, string before, RequestOptions options)
        {
            using PipelineMessage message = CreateGetVectorStoresRequest(limit, order, after, before, options);
            return ClientResult.FromResponse(await _pipeline.ProcessMessageAsync(message, options).ConfigureAwait(false));
        }

        /// <summary>
        /// [Protocol Method] Returns a list of vector-stores.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://aka.ms/azsdk/net/protocol-methods">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetVectorStores(int?,global::OpenAI.Models.ListOrder?,string,string)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="limit">
        /// A limit on the number of objects to be returned. Limit can range between 1 and 100, and the
        /// default is 20.
        /// </param>
        /// <param name="order">
        /// Sort order by the `created_at` timestamp of the objects. `asc` for ascending order and`desc`
        /// for descending order. Allowed values: "asc" | "desc"
        /// </param>
        /// <param name="after">
        /// A cursor for use in pagination. `after` is an object ID that defines your place in the list.
        /// For instance, if you make a list request and receive 100 objects, ending with obj_foo, your
        /// subsequent call can include after=obj_foo in order to fetch the next page of the list.
        /// </param>
        /// <param name="before">
        /// A cursor for use in pagination. `before` is an object ID that defines your place in the list.
        /// For instance, if you make a list request and receive 100 objects, ending with obj_foo, your
        /// subsequent call can include before=obj_foo in order to fetch the previous page of the list.
        /// </param>
        /// <param name="options"> The request options, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ClientResultException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual ClientResult GetVectorStores(int? limit, string order, string after, string before, RequestOptions options)
        {
            using PipelineMessage message = CreateGetVectorStoresRequest(limit, order, after, before, options);
            return ClientResult.FromResponse(_pipeline.ProcessMessage(message, options));
        }

        /// <summary> Creates a vector store. </summary>
        /// <param name="vectorStore"> The <see cref="CreateVectorStoreRequest"/> to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="vectorStore"/> is null. </exception>
        /// <remarks> Create vector store. </remarks>
        public virtual async Task<ClientResult<VectorStoreObject>> CreateVectorStoreAsync(CreateVectorStoreRequest vectorStore)
        {
            Argument.AssertNotNull(vectorStore, nameof(vectorStore));

            using BinaryContent content = vectorStore.ToBinaryContent();
            ClientResult result = await CreateVectorStoreAsync(content, null).ConfigureAwait(false);
            return ClientResult.FromValue(VectorStoreObject.FromResponse(result.GetRawResponse()), result.GetRawResponse());
        }

        /// <summary> Creates a vector store. </summary>
        /// <param name="vectorStore"> The <see cref="CreateVectorStoreRequest"/> to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="vectorStore"/> is null. </exception>
        /// <remarks> Create vector store. </remarks>
        public virtual ClientResult<VectorStoreObject> CreateVectorStore(CreateVectorStoreRequest vectorStore)
        {
            Argument.AssertNotNull(vectorStore, nameof(vectorStore));

            using BinaryContent content = vectorStore.ToBinaryContent();
            ClientResult result = CreateVectorStore(content, null);
            return ClientResult.FromValue(VectorStoreObject.FromResponse(result.GetRawResponse()), result.GetRawResponse());
        }

        /// <summary>
        /// [Protocol Method] Creates a vector store.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://aka.ms/azsdk/net/protocol-methods">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="CreateVectorStoreAsync(CreateVectorStoreRequest)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="options"> The request options, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="content"/> is null. </exception>
        /// <exception cref="ClientResultException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual async Task<ClientResult> CreateVectorStoreAsync(BinaryContent content, RequestOptions options = null)
        {
            Argument.AssertNotNull(content, nameof(content));

            using PipelineMessage message = CreateCreateVectorStoreRequest(content, options);
            return ClientResult.FromResponse(await _pipeline.ProcessMessageAsync(message, options).ConfigureAwait(false));
        }

        /// <summary>
        /// [Protocol Method] Creates a vector store.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://aka.ms/azsdk/net/protocol-methods">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="CreateVectorStore(CreateVectorStoreRequest)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="options"> The request options, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="content"/> is null. </exception>
        /// <exception cref="ClientResultException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual ClientResult CreateVectorStore(BinaryContent content, RequestOptions options = null)
        {
            Argument.AssertNotNull(content, nameof(content));

            using PipelineMessage message = CreateCreateVectorStoreRequest(content, options);
            return ClientResult.FromResponse(_pipeline.ProcessMessage(message, options));
        }

        /// <summary> Retrieves a vector store. </summary>
        /// <param name="vectorStoreId"> The ID of the vector store to retrieve. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="vectorStoreId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="vectorStoreId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks> Get vector store. </remarks>
        public virtual async Task<ClientResult<VectorStoreObject>> GetVectorStoreAsync(string vectorStoreId)
        {
            Argument.AssertNotNullOrEmpty(vectorStoreId, nameof(vectorStoreId));

            ClientResult result = await GetVectorStoreAsync(vectorStoreId, null).ConfigureAwait(false);
            return ClientResult.FromValue(VectorStoreObject.FromResponse(result.GetRawResponse()), result.GetRawResponse());
        }

        /// <summary> Retrieves a vector store. </summary>
        /// <param name="vectorStoreId"> The ID of the vector store to retrieve. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="vectorStoreId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="vectorStoreId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks> Get vector store. </remarks>
        public virtual ClientResult<VectorStoreObject> GetVectorStore(string vectorStoreId)
        {
            Argument.AssertNotNullOrEmpty(vectorStoreId, nameof(vectorStoreId));

            ClientResult result = GetVectorStore(vectorStoreId, null);
            return ClientResult.FromValue(VectorStoreObject.FromResponse(result.GetRawResponse()), result.GetRawResponse());
        }

        /// <summary>
        /// [Protocol Method] Retrieves a vector store.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://aka.ms/azsdk/net/protocol-methods">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetVectorStoreAsync(string)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="vectorStoreId"> The ID of the vector store to retrieve. </param>
        /// <param name="options"> The request options, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="vectorStoreId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="vectorStoreId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="ClientResultException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual async Task<ClientResult> GetVectorStoreAsync(string vectorStoreId, RequestOptions options)
        {
            Argument.AssertNotNullOrEmpty(vectorStoreId, nameof(vectorStoreId));

            using PipelineMessage message = CreateGetVectorStoreRequest(vectorStoreId, options);
            return ClientResult.FromResponse(await _pipeline.ProcessMessageAsync(message, options).ConfigureAwait(false));
        }

        /// <summary>
        /// [Protocol Method] Retrieves a vector store.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://aka.ms/azsdk/net/protocol-methods">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetVectorStore(string)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="vectorStoreId"> The ID of the vector store to retrieve. </param>
        /// <param name="options"> The request options, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="vectorStoreId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="vectorStoreId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="ClientResultException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual ClientResult GetVectorStore(string vectorStoreId, RequestOptions options)
        {
            Argument.AssertNotNullOrEmpty(vectorStoreId, nameof(vectorStoreId));

            using PipelineMessage message = CreateGetVectorStoreRequest(vectorStoreId, options);
            return ClientResult.FromResponse(_pipeline.ProcessMessage(message, options));
        }

        /// <summary> Modifies a vector store. </summary>
        /// <param name="vectorStoreId"> The ID of the vector store to modify. </param>
        /// <param name="vectorStore"> The <see cref="UpdateVectorStoreRequest"/> to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="vectorStoreId"/> or <paramref name="vectorStore"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="vectorStoreId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks> Modify vector store. </remarks>
        public virtual async Task<ClientResult<VectorStoreObject>> ModifyVectorStoreAsync(string vectorStoreId, UpdateVectorStoreRequest vectorStore)
        {
            Argument.AssertNotNullOrEmpty(vectorStoreId, nameof(vectorStoreId));
            Argument.AssertNotNull(vectorStore, nameof(vectorStore));

            using BinaryContent content = vectorStore.ToBinaryContent();
            ClientResult result = await ModifyVectorStoreAsync(vectorStoreId, content, null).ConfigureAwait(false);
            return ClientResult.FromValue(VectorStoreObject.FromResponse(result.GetRawResponse()), result.GetRawResponse());
        }

        /// <summary> Modifies a vector store. </summary>
        /// <param name="vectorStoreId"> The ID of the vector store to modify. </param>
        /// <param name="vectorStore"> The <see cref="UpdateVectorStoreRequest"/> to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="vectorStoreId"/> or <paramref name="vectorStore"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="vectorStoreId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks> Modify vector store. </remarks>
        public virtual ClientResult<VectorStoreObject> ModifyVectorStore(string vectorStoreId, UpdateVectorStoreRequest vectorStore)
        {
            Argument.AssertNotNullOrEmpty(vectorStoreId, nameof(vectorStoreId));
            Argument.AssertNotNull(vectorStore, nameof(vectorStore));

            using BinaryContent content = vectorStore.ToBinaryContent();
            ClientResult result = ModifyVectorStore(vectorStoreId, content, null);
            return ClientResult.FromValue(VectorStoreObject.FromResponse(result.GetRawResponse()), result.GetRawResponse());
        }

        /// <summary>
        /// [Protocol Method] Modifies a vector store.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://aka.ms/azsdk/net/protocol-methods">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="ModifyVectorStoreAsync(string,UpdateVectorStoreRequest)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="vectorStoreId"> The ID of the vector store to modify. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="options"> The request options, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="vectorStoreId"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="vectorStoreId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="ClientResultException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual async Task<ClientResult> ModifyVectorStoreAsync(string vectorStoreId, BinaryContent content, RequestOptions options = null)
        {
            Argument.AssertNotNullOrEmpty(vectorStoreId, nameof(vectorStoreId));
            Argument.AssertNotNull(content, nameof(content));

            using PipelineMessage message = CreateModifyVectorStoreRequest(vectorStoreId, content, options);
            return ClientResult.FromResponse(await _pipeline.ProcessMessageAsync(message, options).ConfigureAwait(false));
        }

        /// <summary>
        /// [Protocol Method] Modifies a vector store.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://aka.ms/azsdk/net/protocol-methods">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="ModifyVectorStore(string,UpdateVectorStoreRequest)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="vectorStoreId"> The ID of the vector store to modify. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="options"> The request options, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="vectorStoreId"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="vectorStoreId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="ClientResultException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual ClientResult ModifyVectorStore(string vectorStoreId, BinaryContent content, RequestOptions options = null)
        {
            Argument.AssertNotNullOrEmpty(vectorStoreId, nameof(vectorStoreId));
            Argument.AssertNotNull(content, nameof(content));

            using PipelineMessage message = CreateModifyVectorStoreRequest(vectorStoreId, content, options);
            return ClientResult.FromResponse(_pipeline.ProcessMessage(message, options));
        }

        /// <summary> Delete a vector store. </summary>
        /// <param name="vectorStoreId"> The ID of the vector store to delete. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="vectorStoreId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="vectorStoreId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks> Delete vector store. </remarks>
        public virtual async Task<ClientResult<DeleteVectorStoreResponse>> DeleteVectorStoreAsync(string vectorStoreId)
        {
            Argument.AssertNotNullOrEmpty(vectorStoreId, nameof(vectorStoreId));

            ClientResult result = await DeleteVectorStoreAsync(vectorStoreId, null).ConfigureAwait(false);
            return ClientResult.FromValue(DeleteVectorStoreResponse.FromResponse(result.GetRawResponse()), result.GetRawResponse());
        }

        /// <summary> Delete a vector store. </summary>
        /// <param name="vectorStoreId"> The ID of the vector store to delete. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="vectorStoreId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="vectorStoreId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks> Delete vector store. </remarks>
        public virtual ClientResult<DeleteVectorStoreResponse> DeleteVectorStore(string vectorStoreId)
        {
            Argument.AssertNotNullOrEmpty(vectorStoreId, nameof(vectorStoreId));

            ClientResult result = DeleteVectorStore(vectorStoreId, null);
            return ClientResult.FromValue(DeleteVectorStoreResponse.FromResponse(result.GetRawResponse()), result.GetRawResponse());
        }

        /// <summary>
        /// [Protocol Method] Delete a vector store.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://aka.ms/azsdk/net/protocol-methods">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="DeleteVectorStoreAsync(string)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="vectorStoreId"> The ID of the vector store to delete. </param>
        /// <param name="options"> The request options, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="vectorStoreId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="vectorStoreId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="ClientResultException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual async Task<ClientResult> DeleteVectorStoreAsync(string vectorStoreId, RequestOptions options)
        {
            Argument.AssertNotNullOrEmpty(vectorStoreId, nameof(vectorStoreId));

            using PipelineMessage message = CreateDeleteVectorStoreRequest(vectorStoreId, options);
            return ClientResult.FromResponse(await _pipeline.ProcessMessageAsync(message, options).ConfigureAwait(false));
        }

        /// <summary>
        /// [Protocol Method] Delete a vector store.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://aka.ms/azsdk/net/protocol-methods">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="DeleteVectorStore(string)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="vectorStoreId"> The ID of the vector store to delete. </param>
        /// <param name="options"> The request options, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="vectorStoreId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="vectorStoreId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="ClientResultException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual ClientResult DeleteVectorStore(string vectorStoreId, RequestOptions options)
        {
            Argument.AssertNotNullOrEmpty(vectorStoreId, nameof(vectorStoreId));

            using PipelineMessage message = CreateDeleteVectorStoreRequest(vectorStoreId, options);
            return ClientResult.FromResponse(_pipeline.ProcessMessage(message, options));
        }

        /// <summary> Returns a list of vector store files. </summary>
        /// <param name="vectorStoreId"> The ID of the vector store that the files belong to. </param>
        /// <param name="limit">
        /// A limit on the number of objects to be returned. Limit can range between 1 and 100, and the
        /// default is 20.
        /// </param>
        /// <param name="order">
        /// Sort order by the `created_at` timestamp of the objects. `asc` for ascending order and`desc`
        /// for descending order.
        /// </param>
        /// <param name="after">
        /// A cursor for use in pagination. `after` is an object ID that defines your place in the list.
        /// For instance, if you make a list request and receive 100 objects, ending with obj_foo, your
        /// subsequent call can include after=obj_foo in order to fetch the next page of the list.
        /// </param>
        /// <param name="before">
        /// A cursor for use in pagination. `before` is an object ID that defines your place in the list.
        /// For instance, if you make a list request and receive 100 objects, ending with obj_foo, your
        /// subsequent call can include before=obj_foo in order to fetch the previous page of the list.
        /// </param>
        /// <param name="filter"> Filter by file status. One of `in_progress`, `completed`, `failed`, `cancelled`. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="vectorStoreId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="vectorStoreId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks> List vector store files. </remarks>
        public virtual async Task<ClientResult<ListVectorStoreFilesResponse>> GetVectorStoreFilesAsync(string vectorStoreId, int? limit = null, ListOrder? order = null, string after = null, string before = null, BinaryData filter = null)
        {
            Argument.AssertNotNullOrEmpty(vectorStoreId, nameof(vectorStoreId));

            ClientResult result = await GetVectorStoreFilesAsync(vectorStoreId, limit, order?.ToString(), after, before, filter, null).ConfigureAwait(false);
            return ClientResult.FromValue(ListVectorStoreFilesResponse.FromResponse(result.GetRawResponse()), result.GetRawResponse());
        }

        /// <summary> Returns a list of vector store files. </summary>
        /// <param name="vectorStoreId"> The ID of the vector store that the files belong to. </param>
        /// <param name="limit">
        /// A limit on the number of objects to be returned. Limit can range between 1 and 100, and the
        /// default is 20.
        /// </param>
        /// <param name="order">
        /// Sort order by the `created_at` timestamp of the objects. `asc` for ascending order and`desc`
        /// for descending order.
        /// </param>
        /// <param name="after">
        /// A cursor for use in pagination. `after` is an object ID that defines your place in the list.
        /// For instance, if you make a list request and receive 100 objects, ending with obj_foo, your
        /// subsequent call can include after=obj_foo in order to fetch the next page of the list.
        /// </param>
        /// <param name="before">
        /// A cursor for use in pagination. `before` is an object ID that defines your place in the list.
        /// For instance, if you make a list request and receive 100 objects, ending with obj_foo, your
        /// subsequent call can include before=obj_foo in order to fetch the previous page of the list.
        /// </param>
        /// <param name="filter"> Filter by file status. One of `in_progress`, `completed`, `failed`, `cancelled`. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="vectorStoreId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="vectorStoreId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks> List vector store files. </remarks>
        public virtual ClientResult<ListVectorStoreFilesResponse> GetVectorStoreFiles(string vectorStoreId, int? limit = null, ListOrder? order = null, string after = null, string before = null, BinaryData filter = null)
        {
            Argument.AssertNotNullOrEmpty(vectorStoreId, nameof(vectorStoreId));

            ClientResult result = GetVectorStoreFiles(vectorStoreId, limit, order?.ToString(), after, before, filter, null);
            return ClientResult.FromValue(ListVectorStoreFilesResponse.FromResponse(result.GetRawResponse()), result.GetRawResponse());
        }

        /// <summary>
        /// [Protocol Method] Returns a list of vector store files.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://aka.ms/azsdk/net/protocol-methods">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetVectorStoreFilesAsync(string,int?,ListOrder?,string,string,BinaryData)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="vectorStoreId"> The ID of the vector store that the files belong to. </param>
        /// <param name="limit">
        /// A limit on the number of objects to be returned. Limit can range between 1 and 100, and the
        /// default is 20.
        /// </param>
        /// <param name="order">
        /// Sort order by the `created_at` timestamp of the objects. `asc` for ascending order and`desc`
        /// for descending order. Allowed values: "asc" | "desc"
        /// </param>
        /// <param name="after">
        /// A cursor for use in pagination. `after` is an object ID that defines your place in the list.
        /// For instance, if you make a list request and receive 100 objects, ending with obj_foo, your
        /// subsequent call can include after=obj_foo in order to fetch the next page of the list.
        /// </param>
        /// <param name="before">
        /// A cursor for use in pagination. `before` is an object ID that defines your place in the list.
        /// For instance, if you make a list request and receive 100 objects, ending with obj_foo, your
        /// subsequent call can include before=obj_foo in order to fetch the previous page of the list.
        /// </param>
        /// <param name="filter"> Filter by file status. One of `in_progress`, `completed`, `failed`, `cancelled`. </param>
        /// <param name="options"> The request options, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="vectorStoreId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="vectorStoreId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="ClientResultException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual async Task<ClientResult> GetVectorStoreFilesAsync(string vectorStoreId, int? limit, string order, string after, string before, BinaryData filter, RequestOptions options)
        {
            Argument.AssertNotNullOrEmpty(vectorStoreId, nameof(vectorStoreId));

            using PipelineMessage message = CreateGetVectorStoreFilesRequest(vectorStoreId, limit, order, after, before, filter, options);
            return ClientResult.FromResponse(await _pipeline.ProcessMessageAsync(message, options).ConfigureAwait(false));
        }

        /// <summary>
        /// [Protocol Method] Returns a list of vector store files.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://aka.ms/azsdk/net/protocol-methods">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetVectorStoreFiles(string,int?,ListOrder?,string,string,BinaryData)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="vectorStoreId"> The ID of the vector store that the files belong to. </param>
        /// <param name="limit">
        /// A limit on the number of objects to be returned. Limit can range between 1 and 100, and the
        /// default is 20.
        /// </param>
        /// <param name="order">
        /// Sort order by the `created_at` timestamp of the objects. `asc` for ascending order and`desc`
        /// for descending order. Allowed values: "asc" | "desc"
        /// </param>
        /// <param name="after">
        /// A cursor for use in pagination. `after` is an object ID that defines your place in the list.
        /// For instance, if you make a list request and receive 100 objects, ending with obj_foo, your
        /// subsequent call can include after=obj_foo in order to fetch the next page of the list.
        /// </param>
        /// <param name="before">
        /// A cursor for use in pagination. `before` is an object ID that defines your place in the list.
        /// For instance, if you make a list request and receive 100 objects, ending with obj_foo, your
        /// subsequent call can include before=obj_foo in order to fetch the previous page of the list.
        /// </param>
        /// <param name="filter"> Filter by file status. One of `in_progress`, `completed`, `failed`, `cancelled`. </param>
        /// <param name="options"> The request options, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="vectorStoreId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="vectorStoreId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="ClientResultException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual ClientResult GetVectorStoreFiles(string vectorStoreId, int? limit, string order, string after, string before, BinaryData filter, RequestOptions options)
        {
            Argument.AssertNotNullOrEmpty(vectorStoreId, nameof(vectorStoreId));

            using PipelineMessage message = CreateGetVectorStoreFilesRequest(vectorStoreId, limit, order, after, before, filter, options);
            return ClientResult.FromResponse(_pipeline.ProcessMessage(message, options));
        }

        /// <summary> Create a vector store file by attaching a [File](/docs/api-reference/files) to a [vector store](/docs/api-reference/vector-stores/object). </summary>
        /// <param name="vectorStoreId"> The ID of the vector store for which to create a File. </param>
        /// <param name="file"> The <see cref="CreateVectorStoreFileRequest"/> to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="vectorStoreId"/> or <paramref name="file"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="vectorStoreId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks> Create vector store file. </remarks>
        public virtual async Task<ClientResult<VectorStoreFileObject>> CreateVectorStoreFileAsync(string vectorStoreId, CreateVectorStoreFileRequest file)
        {
            Argument.AssertNotNullOrEmpty(vectorStoreId, nameof(vectorStoreId));
            Argument.AssertNotNull(file, nameof(file));

            using BinaryContent content = file.ToBinaryContent();
            ClientResult result = await CreateVectorStoreFileAsync(vectorStoreId, content, null).ConfigureAwait(false);
            return ClientResult.FromValue(VectorStoreFileObject.FromResponse(result.GetRawResponse()), result.GetRawResponse());
        }

        /// <summary> Create a vector store file by attaching a [File](/docs/api-reference/files) to a [vector store](/docs/api-reference/vector-stores/object). </summary>
        /// <param name="vectorStoreId"> The ID of the vector store for which to create a File. </param>
        /// <param name="file"> The <see cref="CreateVectorStoreFileRequest"/> to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="vectorStoreId"/> or <paramref name="file"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="vectorStoreId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks> Create vector store file. </remarks>
        public virtual ClientResult<VectorStoreFileObject> CreateVectorStoreFile(string vectorStoreId, CreateVectorStoreFileRequest file)
        {
            Argument.AssertNotNullOrEmpty(vectorStoreId, nameof(vectorStoreId));
            Argument.AssertNotNull(file, nameof(file));

            using BinaryContent content = file.ToBinaryContent();
            ClientResult result = CreateVectorStoreFile(vectorStoreId, content, null);
            return ClientResult.FromValue(VectorStoreFileObject.FromResponse(result.GetRawResponse()), result.GetRawResponse());
        }

        /// <summary>
        /// [Protocol Method] Create a vector store file by attaching a [File](/docs/api-reference/files) to a [vector store](/docs/api-reference/vector-stores/object).
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://aka.ms/azsdk/net/protocol-methods">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="CreateVectorStoreFileAsync(string,CreateVectorStoreFileRequest)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="vectorStoreId"> The ID of the vector store for which to create a File. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="options"> The request options, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="vectorStoreId"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="vectorStoreId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="ClientResultException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual async Task<ClientResult> CreateVectorStoreFileAsync(string vectorStoreId, BinaryContent content, RequestOptions options = null)
        {
            Argument.AssertNotNullOrEmpty(vectorStoreId, nameof(vectorStoreId));
            Argument.AssertNotNull(content, nameof(content));

            using PipelineMessage message = CreateCreateVectorStoreFileRequest(vectorStoreId, content, options);
            return ClientResult.FromResponse(await _pipeline.ProcessMessageAsync(message, options).ConfigureAwait(false));
        }

        /// <summary>
        /// [Protocol Method] Create a vector store file by attaching a [File](/docs/api-reference/files) to a [vector store](/docs/api-reference/vector-stores/object).
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://aka.ms/azsdk/net/protocol-methods">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="CreateVectorStoreFile(string,CreateVectorStoreFileRequest)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="vectorStoreId"> The ID of the vector store for which to create a File. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="options"> The request options, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="vectorStoreId"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="vectorStoreId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="ClientResultException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual ClientResult CreateVectorStoreFile(string vectorStoreId, BinaryContent content, RequestOptions options = null)
        {
            Argument.AssertNotNullOrEmpty(vectorStoreId, nameof(vectorStoreId));
            Argument.AssertNotNull(content, nameof(content));

            using PipelineMessage message = CreateCreateVectorStoreFileRequest(vectorStoreId, content, options);
            return ClientResult.FromResponse(_pipeline.ProcessMessage(message, options));
        }

        /// <summary> Retrieves a vector store file. </summary>
        /// <param name="vectorStoreId"> The ID of the vector store that the file belongs to. </param>
        /// <param name="fileId"> The ID of the file being retrieved. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="vectorStoreId"/> or <paramref name="fileId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="vectorStoreId"/> or <paramref name="fileId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks> Get vector store file. </remarks>
        public virtual async Task<ClientResult<VectorStoreFileObject>> GetVectorStoreFileAsync(string vectorStoreId, string fileId)
        {
            Argument.AssertNotNullOrEmpty(vectorStoreId, nameof(vectorStoreId));
            Argument.AssertNotNullOrEmpty(fileId, nameof(fileId));

            ClientResult result = await GetVectorStoreFileAsync(vectorStoreId, fileId, null).ConfigureAwait(false);
            return ClientResult.FromValue(VectorStoreFileObject.FromResponse(result.GetRawResponse()), result.GetRawResponse());
        }

        /// <summary> Retrieves a vector store file. </summary>
        /// <param name="vectorStoreId"> The ID of the vector store that the file belongs to. </param>
        /// <param name="fileId"> The ID of the file being retrieved. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="vectorStoreId"/> or <paramref name="fileId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="vectorStoreId"/> or <paramref name="fileId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks> Get vector store file. </remarks>
        public virtual ClientResult<VectorStoreFileObject> GetVectorStoreFile(string vectorStoreId, string fileId)
        {
            Argument.AssertNotNullOrEmpty(vectorStoreId, nameof(vectorStoreId));
            Argument.AssertNotNullOrEmpty(fileId, nameof(fileId));

            ClientResult result = GetVectorStoreFile(vectorStoreId, fileId, null);
            return ClientResult.FromValue(VectorStoreFileObject.FromResponse(result.GetRawResponse()), result.GetRawResponse());
        }

        /// <summary>
        /// [Protocol Method] Retrieves a vector store file.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://aka.ms/azsdk/net/protocol-methods">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetVectorStoreFileAsync(string,string)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="vectorStoreId"> The ID of the vector store that the file belongs to. </param>
        /// <param name="fileId"> The ID of the file being retrieved. </param>
        /// <param name="options"> The request options, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="vectorStoreId"/> or <paramref name="fileId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="vectorStoreId"/> or <paramref name="fileId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="ClientResultException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual async Task<ClientResult> GetVectorStoreFileAsync(string vectorStoreId, string fileId, RequestOptions options)
        {
            Argument.AssertNotNullOrEmpty(vectorStoreId, nameof(vectorStoreId));
            Argument.AssertNotNullOrEmpty(fileId, nameof(fileId));

            using PipelineMessage message = CreateGetVectorStoreFileRequest(vectorStoreId, fileId, options);
            return ClientResult.FromResponse(await _pipeline.ProcessMessageAsync(message, options).ConfigureAwait(false));
        }

        /// <summary>
        /// [Protocol Method] Retrieves a vector store file.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://aka.ms/azsdk/net/protocol-methods">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetVectorStoreFile(string,string)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="vectorStoreId"> The ID of the vector store that the file belongs to. </param>
        /// <param name="fileId"> The ID of the file being retrieved. </param>
        /// <param name="options"> The request options, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="vectorStoreId"/> or <paramref name="fileId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="vectorStoreId"/> or <paramref name="fileId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="ClientResultException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual ClientResult GetVectorStoreFile(string vectorStoreId, string fileId, RequestOptions options)
        {
            Argument.AssertNotNullOrEmpty(vectorStoreId, nameof(vectorStoreId));
            Argument.AssertNotNullOrEmpty(fileId, nameof(fileId));

            using PipelineMessage message = CreateGetVectorStoreFileRequest(vectorStoreId, fileId, options);
            return ClientResult.FromResponse(_pipeline.ProcessMessage(message, options));
        }

        /// <summary> Delete a vector store file. This will remove the file from the vector store but the file itself will not be deleted. To delete the file, use the [delete file](/docs/api-reference/files/delete) endpoint. </summary>
        /// <param name="vectorStoreId"> The ID of the vector store that the file belongs to. </param>
        /// <param name="fileId"> The ID of the file to delete. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="vectorStoreId"/> or <paramref name="fileId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="vectorStoreId"/> or <paramref name="fileId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks> Delete vector store file. </remarks>
        public virtual async Task<ClientResult<DeleteVectorStoreFileResponse>> DeleteVectorStoreFileAsync(string vectorStoreId, string fileId)
        {
            Argument.AssertNotNullOrEmpty(vectorStoreId, nameof(vectorStoreId));
            Argument.AssertNotNullOrEmpty(fileId, nameof(fileId));

            ClientResult result = await DeleteVectorStoreFileAsync(vectorStoreId, fileId, null).ConfigureAwait(false);
            return ClientResult.FromValue(DeleteVectorStoreFileResponse.FromResponse(result.GetRawResponse()), result.GetRawResponse());
        }

        /// <summary> Delete a vector store file. This will remove the file from the vector store but the file itself will not be deleted. To delete the file, use the [delete file](/docs/api-reference/files/delete) endpoint. </summary>
        /// <param name="vectorStoreId"> The ID of the vector store that the file belongs to. </param>
        /// <param name="fileId"> The ID of the file to delete. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="vectorStoreId"/> or <paramref name="fileId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="vectorStoreId"/> or <paramref name="fileId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks> Delete vector store file. </remarks>
        public virtual ClientResult<DeleteVectorStoreFileResponse> DeleteVectorStoreFile(string vectorStoreId, string fileId)
        {
            Argument.AssertNotNullOrEmpty(vectorStoreId, nameof(vectorStoreId));
            Argument.AssertNotNullOrEmpty(fileId, nameof(fileId));

            ClientResult result = DeleteVectorStoreFile(vectorStoreId, fileId, null);
            return ClientResult.FromValue(DeleteVectorStoreFileResponse.FromResponse(result.GetRawResponse()), result.GetRawResponse());
        }

        /// <summary>
        /// [Protocol Method] Delete a vector store file. This will remove the file from the vector store but the file itself will not be deleted. To delete the file, use the [delete file](/docs/api-reference/files/delete) endpoint.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://aka.ms/azsdk/net/protocol-methods">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="DeleteVectorStoreFileAsync(string,string)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="vectorStoreId"> The ID of the vector store that the file belongs to. </param>
        /// <param name="fileId"> The ID of the file to delete. </param>
        /// <param name="options"> The request options, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="vectorStoreId"/> or <paramref name="fileId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="vectorStoreId"/> or <paramref name="fileId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="ClientResultException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual async Task<ClientResult> DeleteVectorStoreFileAsync(string vectorStoreId, string fileId, RequestOptions options)
        {
            Argument.AssertNotNullOrEmpty(vectorStoreId, nameof(vectorStoreId));
            Argument.AssertNotNullOrEmpty(fileId, nameof(fileId));

            using PipelineMessage message = CreateDeleteVectorStoreFileRequest(vectorStoreId, fileId, options);
            return ClientResult.FromResponse(await _pipeline.ProcessMessageAsync(message, options).ConfigureAwait(false));
        }

        /// <summary>
        /// [Protocol Method] Delete a vector store file. This will remove the file from the vector store but the file itself will not be deleted. To delete the file, use the [delete file](/docs/api-reference/files/delete) endpoint.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://aka.ms/azsdk/net/protocol-methods">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="DeleteVectorStoreFile(string,string)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="vectorStoreId"> The ID of the vector store that the file belongs to. </param>
        /// <param name="fileId"> The ID of the file to delete. </param>
        /// <param name="options"> The request options, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="vectorStoreId"/> or <paramref name="fileId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="vectorStoreId"/> or <paramref name="fileId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="ClientResultException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual ClientResult DeleteVectorStoreFile(string vectorStoreId, string fileId, RequestOptions options)
        {
            Argument.AssertNotNullOrEmpty(vectorStoreId, nameof(vectorStoreId));
            Argument.AssertNotNullOrEmpty(fileId, nameof(fileId));

            using PipelineMessage message = CreateDeleteVectorStoreFileRequest(vectorStoreId, fileId, options);
            return ClientResult.FromResponse(_pipeline.ProcessMessage(message, options));
        }

        /// <summary> Create a vector store file batch. </summary>
        /// <param name="vectorStoreId"> The ID of the vector store for which to create a file batch. </param>
        /// <param name="fileBatch"> The <see cref="CreateVectorStoreFileBatchRequest"/> to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="vectorStoreId"/> or <paramref name="fileBatch"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="vectorStoreId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks> Create vector store file batch. </remarks>
        public virtual async Task<ClientResult<VectorStoreFileBatchObject>> CreateVectorStoreFileBatchAsync(string vectorStoreId, CreateVectorStoreFileBatchRequest fileBatch)
        {
            Argument.AssertNotNullOrEmpty(vectorStoreId, nameof(vectorStoreId));
            Argument.AssertNotNull(fileBatch, nameof(fileBatch));

            using BinaryContent content = fileBatch.ToBinaryContent();
            ClientResult result = await CreateVectorStoreFileBatchAsync(vectorStoreId, content, null).ConfigureAwait(false);
            return ClientResult.FromValue(VectorStoreFileBatchObject.FromResponse(result.GetRawResponse()), result.GetRawResponse());
        }

        /// <summary> Create a vector store file batch. </summary>
        /// <param name="vectorStoreId"> The ID of the vector store for which to create a file batch. </param>
        /// <param name="fileBatch"> The <see cref="CreateVectorStoreFileBatchRequest"/> to use. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="vectorStoreId"/> or <paramref name="fileBatch"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="vectorStoreId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks> Create vector store file batch. </remarks>
        public virtual ClientResult<VectorStoreFileBatchObject> CreateVectorStoreFileBatch(string vectorStoreId, CreateVectorStoreFileBatchRequest fileBatch)
        {
            Argument.AssertNotNullOrEmpty(vectorStoreId, nameof(vectorStoreId));
            Argument.AssertNotNull(fileBatch, nameof(fileBatch));

            using BinaryContent content = fileBatch.ToBinaryContent();
            ClientResult result = CreateVectorStoreFileBatch(vectorStoreId, content, null);
            return ClientResult.FromValue(VectorStoreFileBatchObject.FromResponse(result.GetRawResponse()), result.GetRawResponse());
        }

        /// <summary>
        /// [Protocol Method] Create a vector store file batch.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://aka.ms/azsdk/net/protocol-methods">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="CreateVectorStoreFileBatchAsync(string,CreateVectorStoreFileBatchRequest)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="vectorStoreId"> The ID of the vector store for which to create a file batch. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="options"> The request options, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="vectorStoreId"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="vectorStoreId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="ClientResultException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual async Task<ClientResult> CreateVectorStoreFileBatchAsync(string vectorStoreId, BinaryContent content, RequestOptions options = null)
        {
            Argument.AssertNotNullOrEmpty(vectorStoreId, nameof(vectorStoreId));
            Argument.AssertNotNull(content, nameof(content));

            using PipelineMessage message = CreateCreateVectorStoreFileBatchRequest(vectorStoreId, content, options);
            return ClientResult.FromResponse(await _pipeline.ProcessMessageAsync(message, options).ConfigureAwait(false));
        }

        /// <summary>
        /// [Protocol Method] Create a vector store file batch.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://aka.ms/azsdk/net/protocol-methods">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="CreateVectorStoreFileBatch(string,CreateVectorStoreFileBatchRequest)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="vectorStoreId"> The ID of the vector store for which to create a file batch. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="options"> The request options, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="vectorStoreId"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="vectorStoreId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="ClientResultException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual ClientResult CreateVectorStoreFileBatch(string vectorStoreId, BinaryContent content, RequestOptions options = null)
        {
            Argument.AssertNotNullOrEmpty(vectorStoreId, nameof(vectorStoreId));
            Argument.AssertNotNull(content, nameof(content));

            using PipelineMessage message = CreateCreateVectorStoreFileBatchRequest(vectorStoreId, content, options);
            return ClientResult.FromResponse(_pipeline.ProcessMessage(message, options));
        }

        /// <summary> Retrieves a vector store file batch. </summary>
        /// <param name="vectorStoreId"> The ID of the vector store that the file batch belongs to. </param>
        /// <param name="batchId"> The ID of the file batch being retrieved. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="vectorStoreId"/> or <paramref name="batchId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="vectorStoreId"/> or <paramref name="batchId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks> Get vector store file batch. </remarks>
        public virtual async Task<ClientResult<VectorStoreFileBatchObject>> GetVectorStoreFileBatchAsync(string vectorStoreId, string batchId)
        {
            Argument.AssertNotNullOrEmpty(vectorStoreId, nameof(vectorStoreId));
            Argument.AssertNotNullOrEmpty(batchId, nameof(batchId));

            ClientResult result = await GetVectorStoreFileBatchAsync(vectorStoreId, batchId, null).ConfigureAwait(false);
            return ClientResult.FromValue(VectorStoreFileBatchObject.FromResponse(result.GetRawResponse()), result.GetRawResponse());
        }

        /// <summary> Retrieves a vector store file batch. </summary>
        /// <param name="vectorStoreId"> The ID of the vector store that the file batch belongs to. </param>
        /// <param name="batchId"> The ID of the file batch being retrieved. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="vectorStoreId"/> or <paramref name="batchId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="vectorStoreId"/> or <paramref name="batchId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks> Get vector store file batch. </remarks>
        public virtual ClientResult<VectorStoreFileBatchObject> GetVectorStoreFileBatch(string vectorStoreId, string batchId)
        {
            Argument.AssertNotNullOrEmpty(vectorStoreId, nameof(vectorStoreId));
            Argument.AssertNotNullOrEmpty(batchId, nameof(batchId));

            ClientResult result = GetVectorStoreFileBatch(vectorStoreId, batchId, null);
            return ClientResult.FromValue(VectorStoreFileBatchObject.FromResponse(result.GetRawResponse()), result.GetRawResponse());
        }

        /// <summary>
        /// [Protocol Method] Retrieves a vector store file batch.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://aka.ms/azsdk/net/protocol-methods">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetVectorStoreFileBatchAsync(string,string)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="vectorStoreId"> The ID of the vector store that the file batch belongs to. </param>
        /// <param name="batchId"> The ID of the file batch being retrieved. </param>
        /// <param name="options"> The request options, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="vectorStoreId"/> or <paramref name="batchId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="vectorStoreId"/> or <paramref name="batchId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="ClientResultException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual async Task<ClientResult> GetVectorStoreFileBatchAsync(string vectorStoreId, string batchId, RequestOptions options)
        {
            Argument.AssertNotNullOrEmpty(vectorStoreId, nameof(vectorStoreId));
            Argument.AssertNotNullOrEmpty(batchId, nameof(batchId));

            using PipelineMessage message = CreateGetVectorStoreFileBatchRequest(vectorStoreId, batchId, options);
            return ClientResult.FromResponse(await _pipeline.ProcessMessageAsync(message, options).ConfigureAwait(false));
        }

        /// <summary>
        /// [Protocol Method] Retrieves a vector store file batch.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://aka.ms/azsdk/net/protocol-methods">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetVectorStoreFileBatch(string,string)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="vectorStoreId"> The ID of the vector store that the file batch belongs to. </param>
        /// <param name="batchId"> The ID of the file batch being retrieved. </param>
        /// <param name="options"> The request options, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="vectorStoreId"/> or <paramref name="batchId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="vectorStoreId"/> or <paramref name="batchId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="ClientResultException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual ClientResult GetVectorStoreFileBatch(string vectorStoreId, string batchId, RequestOptions options)
        {
            Argument.AssertNotNullOrEmpty(vectorStoreId, nameof(vectorStoreId));
            Argument.AssertNotNullOrEmpty(batchId, nameof(batchId));

            using PipelineMessage message = CreateGetVectorStoreFileBatchRequest(vectorStoreId, batchId, options);
            return ClientResult.FromResponse(_pipeline.ProcessMessage(message, options));
        }

        /// <summary> Cancel a vector store file batch. This attempts to cancel the processing of files in this batch as soon as possible. </summary>
        /// <param name="vectorStoreId"> The ID of the vector store that the file batch belongs to. </param>
        /// <param name="batchId"> The ID of the file batch to cancel. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="vectorStoreId"/> or <paramref name="batchId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="vectorStoreId"/> or <paramref name="batchId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks> Cancel vector store file batch. </remarks>
        public virtual async Task<ClientResult<VectorStoreFileBatchObject>> CancelVectorStoreFileBatchAsync(string vectorStoreId, string batchId)
        {
            Argument.AssertNotNullOrEmpty(vectorStoreId, nameof(vectorStoreId));
            Argument.AssertNotNullOrEmpty(batchId, nameof(batchId));

            ClientResult result = await CancelVectorStoreFileBatchAsync(vectorStoreId, batchId, null).ConfigureAwait(false);
            return ClientResult.FromValue(VectorStoreFileBatchObject.FromResponse(result.GetRawResponse()), result.GetRawResponse());
        }

        /// <summary> Cancel a vector store file batch. This attempts to cancel the processing of files in this batch as soon as possible. </summary>
        /// <param name="vectorStoreId"> The ID of the vector store that the file batch belongs to. </param>
        /// <param name="batchId"> The ID of the file batch to cancel. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="vectorStoreId"/> or <paramref name="batchId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="vectorStoreId"/> or <paramref name="batchId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks> Cancel vector store file batch. </remarks>
        public virtual ClientResult<VectorStoreFileBatchObject> CancelVectorStoreFileBatch(string vectorStoreId, string batchId)
        {
            Argument.AssertNotNullOrEmpty(vectorStoreId, nameof(vectorStoreId));
            Argument.AssertNotNullOrEmpty(batchId, nameof(batchId));

            ClientResult result = CancelVectorStoreFileBatch(vectorStoreId, batchId, null);
            return ClientResult.FromValue(VectorStoreFileBatchObject.FromResponse(result.GetRawResponse()), result.GetRawResponse());
        }

        /// <summary>
        /// [Protocol Method] Cancel a vector store file batch. This attempts to cancel the processing of files in this batch as soon as possible.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://aka.ms/azsdk/net/protocol-methods">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="CancelVectorStoreFileBatchAsync(string,string)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="vectorStoreId"> The ID of the vector store that the file batch belongs to. </param>
        /// <param name="batchId"> The ID of the file batch to cancel. </param>
        /// <param name="options"> The request options, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="vectorStoreId"/> or <paramref name="batchId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="vectorStoreId"/> or <paramref name="batchId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="ClientResultException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual async Task<ClientResult> CancelVectorStoreFileBatchAsync(string vectorStoreId, string batchId, RequestOptions options)
        {
            Argument.AssertNotNullOrEmpty(vectorStoreId, nameof(vectorStoreId));
            Argument.AssertNotNullOrEmpty(batchId, nameof(batchId));

            using PipelineMessage message = CreateCancelVectorStoreFileBatchRequest(vectorStoreId, batchId, options);
            return ClientResult.FromResponse(await _pipeline.ProcessMessageAsync(message, options).ConfigureAwait(false));
        }

        /// <summary>
        /// [Protocol Method] Cancel a vector store file batch. This attempts to cancel the processing of files in this batch as soon as possible.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://aka.ms/azsdk/net/protocol-methods">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="CancelVectorStoreFileBatch(string,string)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="vectorStoreId"> The ID of the vector store that the file batch belongs to. </param>
        /// <param name="batchId"> The ID of the file batch to cancel. </param>
        /// <param name="options"> The request options, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="vectorStoreId"/> or <paramref name="batchId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="vectorStoreId"/> or <paramref name="batchId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="ClientResultException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual ClientResult CancelVectorStoreFileBatch(string vectorStoreId, string batchId, RequestOptions options)
        {
            Argument.AssertNotNullOrEmpty(vectorStoreId, nameof(vectorStoreId));
            Argument.AssertNotNullOrEmpty(batchId, nameof(batchId));

            using PipelineMessage message = CreateCancelVectorStoreFileBatchRequest(vectorStoreId, batchId, options);
            return ClientResult.FromResponse(_pipeline.ProcessMessage(message, options));
        }

        /// <summary> Returns a list of vector store files in a batch. </summary>
        /// <param name="vectorStoreId"> The ID of the vector store that the file batch belongs to. </param>
        /// <param name="batchId"> The ID of the file batch that the files belong to. </param>
        /// <param name="limit">
        /// A limit on the number of objects to be returned. Limit can range between 1 and 100, and the
        /// default is 20.
        /// </param>
        /// <param name="order">
        /// Sort order by the `created_at` timestamp of the objects. `asc` for ascending order and`desc`
        /// for descending order.
        /// </param>
        /// <param name="after">
        /// A cursor for use in pagination. `after` is an object ID that defines your place in the list.
        /// For instance, if you make a list request and receive 100 objects, ending with obj_foo, your
        /// subsequent call can include after=obj_foo in order to fetch the next page of the list.
        /// </param>
        /// <param name="before">
        /// A cursor for use in pagination. `before` is an object ID that defines your place in the list.
        /// For instance, if you make a list request and receive 100 objects, ending with obj_foo, your
        /// subsequent call can include before=obj_foo in order to fetch the previous page of the list.
        /// </param>
        /// <param name="filter"> Filter by file status. One of `in_progress`, `completed`, `failed`, `cancelled`. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="vectorStoreId"/> or <paramref name="batchId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="vectorStoreId"/> or <paramref name="batchId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks> List files in vector store batch. </remarks>
        public virtual async Task<ClientResult<ListVectorStoreFilesResponse>> GetFilesInVectorStoreBatchesAsync(string vectorStoreId, string batchId, int? limit = null, ListOrder? order = null, string after = null, string before = null, BinaryData filter = null)
        {
            Argument.AssertNotNullOrEmpty(vectorStoreId, nameof(vectorStoreId));
            Argument.AssertNotNullOrEmpty(batchId, nameof(batchId));

            ClientResult result = await GetFilesInVectorStoreBatchesAsync(vectorStoreId, batchId, limit, order?.ToString(), after, before, filter, null).ConfigureAwait(false);
            return ClientResult.FromValue(ListVectorStoreFilesResponse.FromResponse(result.GetRawResponse()), result.GetRawResponse());
        }

        /// <summary> Returns a list of vector store files in a batch. </summary>
        /// <param name="vectorStoreId"> The ID of the vector store that the file batch belongs to. </param>
        /// <param name="batchId"> The ID of the file batch that the files belong to. </param>
        /// <param name="limit">
        /// A limit on the number of objects to be returned. Limit can range between 1 and 100, and the
        /// default is 20.
        /// </param>
        /// <param name="order">
        /// Sort order by the `created_at` timestamp of the objects. `asc` for ascending order and`desc`
        /// for descending order.
        /// </param>
        /// <param name="after">
        /// A cursor for use in pagination. `after` is an object ID that defines your place in the list.
        /// For instance, if you make a list request and receive 100 objects, ending with obj_foo, your
        /// subsequent call can include after=obj_foo in order to fetch the next page of the list.
        /// </param>
        /// <param name="before">
        /// A cursor for use in pagination. `before` is an object ID that defines your place in the list.
        /// For instance, if you make a list request and receive 100 objects, ending with obj_foo, your
        /// subsequent call can include before=obj_foo in order to fetch the previous page of the list.
        /// </param>
        /// <param name="filter"> Filter by file status. One of `in_progress`, `completed`, `failed`, `cancelled`. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="vectorStoreId"/> or <paramref name="batchId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="vectorStoreId"/> or <paramref name="batchId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks> List files in vector store batch. </remarks>
        public virtual ClientResult<ListVectorStoreFilesResponse> GetFilesInVectorStoreBatches(string vectorStoreId, string batchId, int? limit = null, ListOrder? order = null, string after = null, string before = null, BinaryData filter = null)
        {
            Argument.AssertNotNullOrEmpty(vectorStoreId, nameof(vectorStoreId));
            Argument.AssertNotNullOrEmpty(batchId, nameof(batchId));

            ClientResult result = GetFilesInVectorStoreBatches(vectorStoreId, batchId, limit, order?.ToString(), after, before, filter, null);
            return ClientResult.FromValue(ListVectorStoreFilesResponse.FromResponse(result.GetRawResponse()), result.GetRawResponse());
        }

        /// <summary>
        /// [Protocol Method] Returns a list of vector store files in a batch.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://aka.ms/azsdk/net/protocol-methods">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetFilesInVectorStoreBatchesAsync(string,string,int?,ListOrder?,string,string,BinaryData)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="vectorStoreId"> The ID of the vector store that the file batch belongs to. </param>
        /// <param name="batchId"> The ID of the file batch that the files belong to. </param>
        /// <param name="limit">
        /// A limit on the number of objects to be returned. Limit can range between 1 and 100, and the
        /// default is 20.
        /// </param>
        /// <param name="order">
        /// Sort order by the `created_at` timestamp of the objects. `asc` for ascending order and`desc`
        /// for descending order. Allowed values: "asc" | "desc"
        /// </param>
        /// <param name="after">
        /// A cursor for use in pagination. `after` is an object ID that defines your place in the list.
        /// For instance, if you make a list request and receive 100 objects, ending with obj_foo, your
        /// subsequent call can include after=obj_foo in order to fetch the next page of the list.
        /// </param>
        /// <param name="before">
        /// A cursor for use in pagination. `before` is an object ID that defines your place in the list.
        /// For instance, if you make a list request and receive 100 objects, ending with obj_foo, your
        /// subsequent call can include before=obj_foo in order to fetch the previous page of the list.
        /// </param>
        /// <param name="filter"> Filter by file status. One of `in_progress`, `completed`, `failed`, `cancelled`. </param>
        /// <param name="options"> The request options, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="vectorStoreId"/> or <paramref name="batchId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="vectorStoreId"/> or <paramref name="batchId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="ClientResultException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual async Task<ClientResult> GetFilesInVectorStoreBatchesAsync(string vectorStoreId, string batchId, int? limit, string order, string after, string before, BinaryData filter, RequestOptions options)
        {
            Argument.AssertNotNullOrEmpty(vectorStoreId, nameof(vectorStoreId));
            Argument.AssertNotNullOrEmpty(batchId, nameof(batchId));

            using PipelineMessage message = CreateGetFilesInVectorStoreBatchesRequest(vectorStoreId, batchId, limit, order, after, before, filter, options);
            return ClientResult.FromResponse(await _pipeline.ProcessMessageAsync(message, options).ConfigureAwait(false));
        }

        /// <summary>
        /// [Protocol Method] Returns a list of vector store files in a batch.
        /// <list type="bullet">
        /// <item>
        /// <description>
        /// This <see href="https://aka.ms/azsdk/net/protocol-methods">protocol method</see> allows explicit creation of the request and processing of the response for advanced scenarios.
        /// </description>
        /// </item>
        /// <item>
        /// <description>
        /// Please try the simpler <see cref="GetFilesInVectorStoreBatches(string,string,int?,ListOrder?,string,string,BinaryData)"/> convenience overload with strongly typed models first.
        /// </description>
        /// </item>
        /// </list>
        /// </summary>
        /// <param name="vectorStoreId"> The ID of the vector store that the file batch belongs to. </param>
        /// <param name="batchId"> The ID of the file batch that the files belong to. </param>
        /// <param name="limit">
        /// A limit on the number of objects to be returned. Limit can range between 1 and 100, and the
        /// default is 20.
        /// </param>
        /// <param name="order">
        /// Sort order by the `created_at` timestamp of the objects. `asc` for ascending order and`desc`
        /// for descending order. Allowed values: "asc" | "desc"
        /// </param>
        /// <param name="after">
        /// A cursor for use in pagination. `after` is an object ID that defines your place in the list.
        /// For instance, if you make a list request and receive 100 objects, ending with obj_foo, your
        /// subsequent call can include after=obj_foo in order to fetch the next page of the list.
        /// </param>
        /// <param name="before">
        /// A cursor for use in pagination. `before` is an object ID that defines your place in the list.
        /// For instance, if you make a list request and receive 100 objects, ending with obj_foo, your
        /// subsequent call can include before=obj_foo in order to fetch the previous page of the list.
        /// </param>
        /// <param name="filter"> Filter by file status. One of `in_progress`, `completed`, `failed`, `cancelled`. </param>
        /// <param name="options"> The request options, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="vectorStoreId"/> or <paramref name="batchId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="vectorStoreId"/> or <paramref name="batchId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="ClientResultException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        public virtual ClientResult GetFilesInVectorStoreBatches(string vectorStoreId, string batchId, int? limit, string order, string after, string before, BinaryData filter, RequestOptions options)
        {
            Argument.AssertNotNullOrEmpty(vectorStoreId, nameof(vectorStoreId));
            Argument.AssertNotNullOrEmpty(batchId, nameof(batchId));

            using PipelineMessage message = CreateGetFilesInVectorStoreBatchesRequest(vectorStoreId, batchId, limit, order, after, before, filter, options);
            return ClientResult.FromResponse(_pipeline.ProcessMessage(message, options));
        }

        internal PipelineMessage CreateGetVectorStoresRequest(int? limit, string order, string after, string before, RequestOptions options)
        {
            var message = _pipeline.CreateMessage();
            message.ResponseClassifier = PipelineMessageClassifier200;
            var request = message.Request;
            request.Method = "GET";
            var uri = new ClientUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/vector_stores", false);
            if (limit != null)
            {
                uri.AppendQuery("limit", limit.Value, true);
            }
            if (order != null)
            {
                uri.AppendQuery("order", order, true);
            }
            if (after != null)
            {
                uri.AppendQuery("after", after, true);
            }
            if (before != null)
            {
                uri.AppendQuery("before", before, true);
            }
            request.Uri = uri.ToUri();
            request.Headers.Set("Accept", "application/json");
            if (options != null) { message.Apply(options); }
            return message;
        }

        internal PipelineMessage CreateCreateVectorStoreRequest(BinaryContent content, RequestOptions options)
        {
            var message = _pipeline.CreateMessage();
            message.ResponseClassifier = PipelineMessageClassifier200;
            var request = message.Request;
            request.Method = "POST";
            var uri = new ClientUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/vector_stores", false);
            request.Uri = uri.ToUri();
            request.Headers.Set("Accept", "application/json");
            request.Headers.Set("Content-Type", "application/json");
            request.Content = content;
            if (options != null) { message.Apply(options); }
            return message;
        }

        internal PipelineMessage CreateGetVectorStoreRequest(string vectorStoreId, RequestOptions options)
        {
            var message = _pipeline.CreateMessage();
            message.ResponseClassifier = PipelineMessageClassifier200;
            var request = message.Request;
            request.Method = "GET";
            var uri = new ClientUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/vector_stores/", false);
            uri.AppendPath(vectorStoreId, true);
            request.Uri = uri.ToUri();
            request.Headers.Set("Accept", "application/json");
            if (options != null) { message.Apply(options); }
            return message;
        }

        internal PipelineMessage CreateModifyVectorStoreRequest(string vectorStoreId, BinaryContent content, RequestOptions options)
        {
            var message = _pipeline.CreateMessage();
            message.ResponseClassifier = PipelineMessageClassifier200;
            var request = message.Request;
            request.Method = "POST";
            var uri = new ClientUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/vector_stores/", false);
            uri.AppendPath(vectorStoreId, true);
            request.Uri = uri.ToUri();
            request.Headers.Set("Accept", "application/json");
            request.Headers.Set("Content-Type", "application/json");
            request.Content = content;
            if (options != null) { message.Apply(options); }
            return message;
        }

        internal PipelineMessage CreateDeleteVectorStoreRequest(string vectorStoreId, RequestOptions options)
        {
            var message = _pipeline.CreateMessage();
            message.ResponseClassifier = PipelineMessageClassifier200;
            var request = message.Request;
            request.Method = "DELETE";
            var uri = new ClientUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/vector_stores/", false);
            uri.AppendPath(vectorStoreId, true);
            request.Uri = uri.ToUri();
            request.Headers.Set("Accept", "application/json");
            if (options != null) { message.Apply(options); }
            return message;
        }

        internal PipelineMessage CreateGetVectorStoreFilesRequest(string vectorStoreId, int? limit, string order, string after, string before, BinaryData filter, RequestOptions options)
        {
            var message = _pipeline.CreateMessage();
            message.ResponseClassifier = PipelineMessageClassifier200;
            var request = message.Request;
            request.Method = "GET";
            var uri = new ClientUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/vector_stores/", false);
            uri.AppendPath(vectorStoreId, true);
            uri.AppendPath("/files", false);
            if (limit != null)
            {
                uri.AppendQuery("limit", limit.Value, true);
            }
            if (order != null)
            {
                uri.AppendQuery("order", order, true);
            }
            if (after != null)
            {
                uri.AppendQuery("after", after, true);
            }
            if (before != null)
            {
                uri.AppendQuery("before", before, true);
            }
            if (filter != null)
            {
                uri.AppendQuery("filter", filter.ToArray(), true);
            }
            request.Uri = uri.ToUri();
            request.Headers.Set("Accept", "application/json");
            if (options != null) { message.Apply(options); }
            return message;
        }

        internal PipelineMessage CreateCreateVectorStoreFileRequest(string vectorStoreId, BinaryContent content, RequestOptions options)
        {
            var message = _pipeline.CreateMessage();
            message.ResponseClassifier = PipelineMessageClassifier200;
            var request = message.Request;
            request.Method = "POST";
            var uri = new ClientUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/vector_stores/", false);
            uri.AppendPath(vectorStoreId, true);
            uri.AppendPath("/files", false);
            request.Uri = uri.ToUri();
            request.Headers.Set("Accept", "application/json");
            request.Headers.Set("Content-Type", "application/json");
            request.Content = content;
            if (options != null) { message.Apply(options); }
            return message;
        }

        internal PipelineMessage CreateGetVectorStoreFileRequest(string vectorStoreId, string fileId, RequestOptions options)
        {
            var message = _pipeline.CreateMessage();
            message.ResponseClassifier = PipelineMessageClassifier200;
            var request = message.Request;
            request.Method = "GET";
            var uri = new ClientUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/vector_stores/", false);
            uri.AppendPath(vectorStoreId, true);
            uri.AppendPath("/files/", false);
            uri.AppendPath(fileId, true);
            request.Uri = uri.ToUri();
            request.Headers.Set("Accept", "application/json");
            if (options != null) { message.Apply(options); }
            return message;
        }

        internal PipelineMessage CreateDeleteVectorStoreFileRequest(string vectorStoreId, string fileId, RequestOptions options)
        {
            var message = _pipeline.CreateMessage();
            message.ResponseClassifier = PipelineMessageClassifier200;
            var request = message.Request;
            request.Method = "DELETE";
            var uri = new ClientUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/vector_stores/", false);
            uri.AppendPath(vectorStoreId, true);
            uri.AppendPath("/files/", false);
            uri.AppendPath(fileId, true);
            request.Uri = uri.ToUri();
            request.Headers.Set("Accept", "application/json");
            if (options != null) { message.Apply(options); }
            return message;
        }

        internal PipelineMessage CreateCreateVectorStoreFileBatchRequest(string vectorStoreId, BinaryContent content, RequestOptions options)
        {
            var message = _pipeline.CreateMessage();
            message.ResponseClassifier = PipelineMessageClassifier200;
            var request = message.Request;
            request.Method = "POST";
            var uri = new ClientUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/vector_stores/", false);
            uri.AppendPath(vectorStoreId, true);
            uri.AppendPath("/file_batches", false);
            request.Uri = uri.ToUri();
            request.Headers.Set("Accept", "application/json");
            request.Headers.Set("Content-Type", "application/json");
            request.Content = content;
            if (options != null) { message.Apply(options); }
            return message;
        }

        internal PipelineMessage CreateGetVectorStoreFileBatchRequest(string vectorStoreId, string batchId, RequestOptions options)
        {
            var message = _pipeline.CreateMessage();
            message.ResponseClassifier = PipelineMessageClassifier200;
            var request = message.Request;
            request.Method = "GET";
            var uri = new ClientUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/vector_stores/", false);
            uri.AppendPath(vectorStoreId, true);
            uri.AppendPath("/file_batches/", false);
            uri.AppendPath(batchId, true);
            request.Uri = uri.ToUri();
            request.Headers.Set("Accept", "application/json");
            if (options != null) { message.Apply(options); }
            return message;
        }

        internal PipelineMessage CreateCancelVectorStoreFileBatchRequest(string vectorStoreId, string batchId, RequestOptions options)
        {
            var message = _pipeline.CreateMessage();
            message.ResponseClassifier = PipelineMessageClassifier200;
            var request = message.Request;
            request.Method = "POST";
            var uri = new ClientUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/vector_stores/", false);
            uri.AppendPath(vectorStoreId, true);
            uri.AppendPath("/file_batches/", false);
            uri.AppendPath(batchId, true);
            uri.AppendPath("/cancel", false);
            request.Uri = uri.ToUri();
            request.Headers.Set("Accept", "application/json");
            if (options != null) { message.Apply(options); }
            return message;
        }

        internal PipelineMessage CreateGetFilesInVectorStoreBatchesRequest(string vectorStoreId, string batchId, int? limit, string order, string after, string before, BinaryData filter, RequestOptions options)
        {
            var message = _pipeline.CreateMessage();
            message.ResponseClassifier = PipelineMessageClassifier200;
            var request = message.Request;
            request.Method = "GET";
            var uri = new ClientUriBuilder();
            uri.Reset(_endpoint);
            uri.AppendPath("/vector_stores/", false);
            uri.AppendPath(vectorStoreId, true);
            uri.AppendPath("/file_batches/", false);
            uri.AppendPath(batchId, true);
            uri.AppendPath("/files", false);
            if (limit != null)
            {
                uri.AppendQuery("limit", limit.Value, true);
            }
            if (order != null)
            {
                uri.AppendQuery("order", order, true);
            }
            if (after != null)
            {
                uri.AppendQuery("after", after, true);
            }
            if (before != null)
            {
                uri.AppendQuery("before", before, true);
            }
            if (filter != null)
            {
                uri.AppendQuery("filter", filter.ToArray(), true);
            }
            request.Uri = uri.ToUri();
            request.Headers.Set("Accept", "application/json");
            if (options != null) { message.Apply(options); }
            return message;
        }

        private static PipelineMessageClassifier _pipelineMessageClassifier200;
        private static PipelineMessageClassifier PipelineMessageClassifier200 => _pipelineMessageClassifier200 ??= PipelineMessageClassifier.Create(stackalloc ushort[] { 200 });
    }
}
